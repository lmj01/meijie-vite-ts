function withStateTransactions(t){return{...t,created(){this.state=this._monitorTransactionState(this._state),this.setState=(t,s)=>{const setter=t=>{if(!t||"object"!=typeof t)return;const a=this.transaction,n=this.updated;s&&(this.updated=()=>{setTimeout(s),this.updated=n||void 0}),a||this.beginTransaction();for(const s in t)this.state[s]&&this.state[s]===t[s]||(this.state[s]=t[s]);a||this.endTransaction()},a=t(this.state);var n;"object"!=typeof(n=a)&&"function"!=typeof n||"function"!=typeof n.then?setter(a):a.then(setter)},t.created&&t.created.call(this)},beginTransaction(){this.transactionCache={},this.transaction=!0,this.status="transaction"},endTransaction(){this.transaction=!1,this.status="render",this._processRender()},rollbackTransaction(){Object.keys(this.transactionCache).forEach((t=>this.state[t]=this.transactionCache[t])),this.endTransaction()},_monitorTransactionState(t){const s=this;return new Proxy(t,{set:(t,a,n)=>(t[a]===n||(s.transaction&&!s.transactionCache[a]&&(s.transactionCache[a]=s._copyValue(t[a])),t[a]=n,s.computedCache={},"render"===s.status&&s._processRender()),!0),get:(t,s)=>t[s]})},_copyValue:t=>JSON.parse(JSON.stringify(t))}}export{withStateTransactions};
